<!-- .slide: data-background="#ffffffff" -->

<section data-transition="none">

### w6.1 – Input encoding theory background <!-- .element: class="r-fit-text" -->

- [w6.1.1] Introduction to input encoding
- [w6.1.2] Basis encoding
- [w6.1.3] Amplitude encoding
- [w6.1.4] Time evolution encoding
- [w6.1.5] Hamiltonian encoding
- [w6.1.6] Angle encoding 
- [w6.1.7] Phase encoding 

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.1 – Introduction to input encoding <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Quantum algorithms operate on <i>quantum states</i>, meaning classical data must be embedded into a Hilbert space before any quantum processing can happen.
  </p>

  <p>
    Input encoding determines:
    <ul>
      <li>How classical feature vectors are mapped to quantum states</li>
      <li>The expressive power and geometry of the resulting state space</li>
      <li>The depth and complexity of the quantum circuit</li>
      <li>The type of patterns a quantum model can learn</li>
    </ul>
  </p>

  <p>
    Different encodings emphasize different structures:
    <ul>
      <li><b>Basis encoding</b> → discrete & binary data</li>
      <li><b>Amplitude encoding</b> → high-dimensional continuous vectors</li>
      <li><b>Angle encoding</b> → individually parameterized features</li>
      <li><b>Hamiltonian / Time evolution</b> → correlations & dynamics</li>
      <li><b>Phase encoding</b> → interference-based nonlinear transformations</li>
    </ul>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.2 – Basis encoding (1) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Basis encoding associates a computational basis state of an \(n\)-qubit system with a classical \(n\)-bit string. Each bit gets literally replaced by a qubit.
  </p>

  <p>
    For a bit string $x = x_1 x_2 \dots x_n$, the encoded quantum state is 
    $|x\rangle = |x_1\rangle \otimes |x_2\rangle \otimes \cdots \otimes |x_n\rangle .$
  </p>

  <p>
    In vector notation, using the standard basis:
    $|0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix} \in \mathbb{C}^2, \qquad |1\rangle = \begin{pmatrix} 0 \\ 1 \end{pmatrix} \in \mathbb{C}^2$
  </p>

  <p>
    Properties:
    <ul>
      <li>Simple, hardware-efficient</li>
      <li>No superposition — a classical-like representation</li>
      <li>Each classical bit → one qubit</li>
    </ul>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.2 – Basis encoding (2) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Basis encoding uses only Pauli-X gates for bits equal to 1:
    $X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \qquad x_i = 1 \Rightarrow X_i |0\rangle = |1\rangle$
  </p>

  <p>
    <b>Example:</b> Encoding the vector $\mathbf{x} = (0.1, -0.6, 1.0)$ with binary fraction representation $\tau = 4$:
  </p>
  <p>
    First, translate each entry (first bit = sign):
    $\begin{align}
    0.1 &\rightarrow 0\,0001 \\
    -0.6 &\rightarrow 1\,1001 \\
    1.0 &\rightarrow 0\,1111
    \end{align}$
  </p>
  <p>
    Concatenate: $b = 00001\,11001\,01111$
  </p>
  <p>
    The quantum state is: $|00001\,11001\,01111\rangle$
  </p>
  <p>
    <small>This requires 15 qubits for 3 values — basis encoding is qubit-intensive!</small>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.2 – Basis encoding (3) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Advantages:
    <ul>
      <li>Very shallow circuits (only X gates where needed)</li>
      <li>Ideal for NISQ devices</li>
      <li>Suitable for categorical data (cloud masks, land cover classes)</li>
    </ul>
  </p>
  <p>
    Limitations:
    <ul>
      <li>Linear scaling: $n$ bits require $n$ qubits</li>
      <li>Cannot directly store high-dimensional continuous data</li>
      <li>No expressive superposition structure</li>
    </ul>
  </p>
  <p>
    <b>Note:</b> Binary representation requires choosing precision. A real number $x \in [0,1)$ with $\tau$ bits:
    $x = \sum_{k=0}^{\tau-1} b_k \frac{1}{2^k}$
    where $b_k \in \{0,1\}$.
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.3 – Amplitude encoding (1) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Amplitude encoding embeds a normalised classical vector $\mathbf{x} \in \mathbb{R}^{2^n}$ into the amplitudes of an $n$-qubit state:
    $|\psi_{\mathbf{x}}\rangle = \sum_{i=0}^{2^n-1} x_i |i\rangle$
  </p>

  <p>
    where $\sum_i |x_i|^2 = 1$ (normalisation constraint).
  </p>

  <p>
    In compact notation:
    $|\psi\rangle = \sum_{i=0}^{2^n-1} \alpha_i |i\rangle$
    where $|i\rangle$ refers to the computational basis state whose binary representation is integer $i$.
  </p>

  <p>
    <b>Key advantage:</b> $n$ qubits encode $2^n$ features — exponential compression!
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.3 – Amplitude encoding (2) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    <b>Example:</b> Encoding $\mathbf{x} = (0.1, -0.6, 1.0)$ in amplitude encoding.
  </p>
  <p>
    Step 1: Normalise to unit length
    $\|\mathbf{x}\| = \sqrt{0.1^2 + (-0.6)^2 + 1.0^2} = \sqrt{1.37} \approx 1.170$
    $\mathbf{x}_{\text{norm}} = \frac{\mathbf{x}}{\|\mathbf{x}\|} = (0.085, -0.513, 0.855)$
  </p>
  <p>
    Step 2: Pad with zeros to reach $2^n$ dimensions
    $\mathbf{x}_{\text{padded}} = (0.085, -0.513, 0.855, 0.000)$
  </p>
  <p>
    Step 3: Encode as 2-qubit state
    $|\psi_{\mathbf{x}}\rangle = 0.085|00\rangle - 0.513|01\rangle + 0.855|10\rangle + 0|11\rangle$
  </p>
  <p>
    <small>Only 2 qubits needed vs. 15 for basis encoding!</small>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.3 – Amplitude encoding (3) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    The same vector can encode a matrix. Interpreting first qubit as row index, second as column index:
    $A = \begin{pmatrix} 0.085 & -0.513 \\ 0.855 & 0.000 \end{pmatrix}$
  </p>

  <p>
    For matrix encoding more generally:
    $|\psi_A\rangle = \sum_{i=0}^{2^m-1} \sum_{j=0}^{2^n-1} a_{ij} |i\rangle|j\rangle$
    where $A \in \mathbb{C}^{2^m \times 2^n}$ with $\sum_{ij} |a_{ij}|^2 = 1$.
  </p>

  <p>
    Advantages:
    <ul>
      <li>Exponential information density</li>
      <li>Rich interference patterns possible</li>
    </ul>
    Limitations:
    <ul>
      <li>State preparation is costly (not NISQ-friendly)</li>
      <li>Must be normalised (loses magnitude information)</li>
      <li>Requires $2^n$ dimensions</li>
    </ul>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.4 – Time evolution encoding (1) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Time evolution encoding prescribes associating a scalar value $x \in \mathbb{R}$ with the time $t$ in the unitary evolution:
    $U(x) = e^{-ix H}$
    where $H$ is a Hamiltonian operator.
  </p>

  <p>
    For a simple single-qubit Hamiltonian $H = \frac{1}{2}\sigma_z$:
    $U(x) = e^{-ix\sigma_z/2} = R_Z(x) = \begin{pmatrix} e^{-ix/2} & 0 \\ 0 & e^{ix/2} \end{pmatrix}$
  </p>

  <p>
    This is the Pauli rotation gate around the Z-axis.
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.4 – Time evolution encoding (2) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    <b>Example:</b> Encoding $x = -0.513$ using $R_Y$ rotation on $|0\rangle$:
    $R_Y(\theta) = \begin{pmatrix} \cos(\theta/2) & -\sin(\theta/2) \\ \sin(\theta/2) & \cos(\theta/2) \end{pmatrix}$
  </p>
  <p>
    With $\theta = -0.513$:
    $|\psi(-0.513)\rangle = R_Y(-0.513)|0\rangle$
    $= \cos(-0.513/2)|0\rangle + \sin(-0.513/2)|1\rangle$
    $\approx 0.974|0\rangle - 0.253|1\rangle$
  </p>

  <p>
    For a vector $\mathbf{x} = (x_1, x_2, \ldots, x_N)$, apply successive rotations:
    $|\psi\rangle = R_Y(x_N) \cdots R_Y(x_2) R_Y(x_1) |0\rangle^{\otimes N}$
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.4 – Time evolution encoding (3) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Two-qubit Hamiltonians create entanglement. For $H = x(\sigma_z \otimes \sigma_z)$:
    $U(x) = e^{-ix(\sigma_z \otimes \sigma_z)}$
  </p>

  <p>
    In matrix form ($\sigma_z \otimes \sigma_z$ is diagonal with entries $\{1, -1, -1, 1\}$):
    $U(x) = \begin{pmatrix} 
    e^{-ix} & 0 & 0 & 0 \\
    0 & e^{ix} & 0 & 0 \\
    0 & 0 & e^{ix} & 0 \\
    0 & 0 & 0 & e^{-ix}
    \end{pmatrix}$
  </p>

  <p>
    This naturally encodes correlations between qubits, useful for:
    <ul>
      <li>Multi-band spectral correlations (e.g., NDVI = f(NIR, Red))</li>
      <li>Spatial pixel relationships</li>
      <li>Multi-temporal features</li>
    </ul>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.5 – Hamiltonian encoding (1) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Hamiltonian encoding constructs a data-dependent Hamiltonian:
    $H(\mathbf{x}) = \sum_i x_i H_i$
    where each $H_i$ is a Hermitian operator and $x_i$ are data values.
  </p>

  <p>
    The encoded state (see discussion on Hamiltonian simulation on reference book):
    $|\psi(\mathbf{x})\rangle = e^{-iH(\mathbf{x})t} |0\rangle^{\otimes n}$
  </p>

  <p>
    If $H(\mathbf{x})$ is not Hermitian, use the trick from reference book Eq. 3.67:
    $H_A = \begin{pmatrix} 0 & A \\ A^\dagger & 0 \end{pmatrix}$
    which doubles the Hilbert space dimension.
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.5 – Hamiltonian encoding (2) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    <b>Example:</b> Encoding matrix $A = \begin{pmatrix} 0.085 & -0.513 \\ 0.855 & 0 \end{pmatrix}$
  </p>
  <p>
    Since $A$ is not Hermitian, construct:
    $H_A = \begin{pmatrix} 
    0 & 0 & 0.085 & -0.513 \\
    0 & 0 & 0.855 & 0 \\
    0.085 & 0.855 & 0 & 0 \\
    -0.513 & 0 & 0 & 0
    \end{pmatrix}$
  </p>

  <p>
    The eigenvalues of $H_A$ are: $\{\pm 0.863, \pm 0.510\}$
  </p>

  <p>
    Applying $e^{-iH_A t}$ to a state encodes $A$ into the time evolution. This is used in the HHL algorithm for matrix inversion.
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.5 – Hamiltonian encoding (3) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Typical Hamiltonian choices:
  </p>
  <p>
    Local terms:
    $H = \sum_{i=1}^n \sum_{\alpha \in \{x,y,z,1\}} h_i^\alpha \sigma_i^\alpha$
  </p>
  <p>
    Pairwise interactions:
    $H = \sum_{i,j=1}^n \sum_{\alpha,\beta \in \{x,y,z,1\}} h_{ij}^{\alpha,\beta} \sigma_i^\alpha \sigma_j^\beta$
  </p>

  <p>
    These produce rich entangled states capturing:
    <ul>
      <li>Feature correlations (spectral band relationships)</li>
      <li>Spatial structure (texture patterns)</li>
      <li>Physical constraints (atmospheric models)</li>
    </ul>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.6 – Angle encoding (1) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Angle encoding maps each feature $x_i$ to a rotation angle. For $N$ features and $N$ qubits:
    $|\psi\rangle = \bigotimes_{i=1}^N R(\theta_i) |0\rangle, \qquad \theta_i = \pi x_i$
  </p>

  <p>
    Common rotations:
    $R_x(\theta) = e^{-i\theta\sigma_x/2} = \begin{pmatrix} \cos(\theta/2) & -i\sin(\theta/2) \\ -i\sin(\theta/2) & \cos(\theta/2) \end{pmatrix}$
    $R_y(\theta) = e^{-i\theta\sigma_y/2} = \begin{pmatrix} \cos(\theta/2) & -\sin(\theta/2) \\ \sin(\theta/2) & \cos(\theta/2) \end{pmatrix}$
    $R_z(\theta) = e^{-i\theta\sigma_z/2} = \begin{pmatrix} e^{-i\theta/2} & 0 \\ 0 & e^{i\theta/2} \end{pmatrix}$
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.6 – Angle encoding (2) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    <b>Example:</b> Encoding $\mathbf{x} = (0.1, -0.6, 1.0)$ with $R_Y$ gates and $\theta_i = \pi x_i$:
  </p>
  <p>
    For $x_1 = 0.1$: $\theta_1 = 0.1\pi \approx 0.314$
    $|\psi_1\rangle = \cos(0.157)|0\rangle + \sin(0.157)|1\rangle \approx 0.988|0\rangle + 0.156|1\rangle$
  </p>
  <p>
    For $x_2 = -0.6$: $\theta_2 = -0.6\pi \approx -1.885$
    $|\psi_2\rangle = \cos(-0.942)|0\rangle + \sin(-0.942)|1\rangle \approx 0.588|0\rangle - 0.809|1\rangle$
  </p>
  <p>
    For $x_3 = 1.0$: $\theta_3 = \pi$
    $|\psi_3\rangle = \cos(\pi/2)|0\rangle + \sin(\pi/2)|1\rangle = |1\rangle$
  </p>
  <p>
    Full state: $|\psi\rangle = |\psi_1\rangle \otimes |\psi_2\rangle \otimes |\psi_3\rangle$ (8-dimensional)
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.6 – Angle encoding (3) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    General form for single qubit after $R_Y(\theta)$:
    $|\psi\rangle = \cos\left(\frac{\theta}{2}\right)|0\rangle + \sin\left(\frac{\theta}{2}\right)|1\rangle$
  </p>

  <p>
    This creates a Fourier-like dependency on inputs — the cosine/sine structure gives periodic feature maps.
  </p>

  <p>
    Characteristics:
    <ul>
      <li>Linear scaling: $n$ qubits for $n$ features</li>
      <li>Shallow circuits (one rotation per feature)</li>
      <li>Creates superposition states</li>
      <li>Highly interpretable</li>
      <li>Widely used in variational quantum circuits</li>
    </ul>
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.7 – Phase encoding (1) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    Phase encoding embeds features into <i>relative phases</i> of quantum amplitudes:
    $|\psi\rangle = \frac{1}{\sqrt{2^n}}\sum_{i=0}^{2^n-1} e^{i\phi(i,\mathbf{x})} |i\rangle$
  </p>

  <p>
    IQP (Instantaneous Quantum Polynomial) style encoding:
    <ol>
      <li>Create uniform superposition: $H^{\otimes n}|0\rangle^{\otimes n} = \frac{1}{\sqrt{2^n}}\sum_i |i\rangle$</li>
      <li>Apply diagonal phase operators: $D(\mathbf{x}) = e^{i\sum_j x_j Z_j}$</li>
      <li>Apply pairwise phases: $e^{i\sum_{j\lt k}x_j x_k Z_j Z_k}$</li>
    </ol>
  </p>

  <p>
    This creates nonlinear feature interactions through phase interference.
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.7 – Phase encoding (2) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    <b>Example:</b> Single-qubit phase encoding of $x = 0.5$:
  </p>
  <p>
    Start with superposition:
    $|\psi_0\rangle = H|0\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$
  </p>
  <p>
    Apply phase gate $P(\phi) = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\phi} \end{pmatrix}$ with $\phi = 2\pi x = \pi$:
    $|\psi\rangle = P(\pi)|\psi_0\rangle = \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi}|1\rangle) = \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$
  </p>

  <p>
    For 2 qubits with $\mathbf{x} = (x_1, x_2)$, include interaction term:
    $|\psi\rangle = \frac{1}{2}\sum_{i,j \in \{0,1\}} e^{i(x_1 z_i + x_2 z_j + x_1 x_2 z_i z_j)}|ij\rangle$
    where $z_0 = 0, z_1 = 1$. This creates multiplicative feature interactions.
  </p>
</div>

</section>

<!-- ============================================================================ -->

<section data-transition="none">

### w6.1.7 – Phase encoding (3) <!-- .element: class="r-fit-text" -->
<div style="text-align: justify;">
  <p>
    General phase shift operation on computational basis:
    $|0\rangle \rightarrow |0\rangle, \qquad |1\rangle \rightarrow e^{i\phi}|1\rangle$
  </p>

  <p>
    Advantages:
    <ul>
      <li>Very expressive — creates nonlinear feature maps</li>
      <li>Feature-feature multiplicative interactions</li>
      <li>Interference-driven transformations</li>
      <li>IQP circuits are classically hard (potential quantum advantage)</li>
    </ul>
  </p>

  <p>
    Applications:
    <ul>
      <li>Classification tasks with complex decision boundaries</li>
      <li>Problems requiring nonlinear separability</li>
      <li>Kernel methods in quantum machine learning</li>
    </ul>
  </p>
</div>

</section>